#!/usr/bin/env python
import sys
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mlp
import ScopeTrace
from pylandau import langau
import iminuit

mlp.rcParams['axes.linewidth'] = 2
for filename in sys.argv[1:]:
    print ' File to open: ' + filename
    with open(filename,"r") as file:
        data = file.read()
# decode the scope trace
trace = ScopeTrace.ScopeTrace(data,1)

# find baseline and jitter
baseline,jitter = trace.find_baseline_and_jitter(0,250)
#print ' Baseline: %10.6f,  Jitter: %10.6f'%(baseline,jitter)

inverted_yvalues = []
for value in trace.yvalues:
    inverted_yvalue = -(value-baseline)
    inverted_yvalues.append(inverted_yvalue)

def fit_landau_migrad(x, y, p0, limit_mpv, limit_eta, limit_sigma, limit_A):
    def minimizeMe(mpv, eta, sigma, A):
        chi2 = np.sum(np.square(y-langau(x, mpv, eta, sigma, A).astype(float))/ np.square(yerr.astype(float))
       # return chi2 / (x.shape[0] -5)

    yerr = np.sqrt(y)
    yerr[y<1] = 1
    m = iminuit.Minuit(minimizeMe, 
                       mpv = p0 [0], limit_mpv = limit_mpv, error_mpv = 1, 
                       eta = p0[1], error_eta = .1, limit_eta = limit_eta, 
                       sigma= p0[2], error_sigma = .1, limit_sigma = limit_sigma, 
                       A = p0[3], error_A= 1, limit_A = limit_A, errordef = 1, print_level = 2)
    m.migrad()
    if not m.get_fmin().is_valid:
        raise RuntimeError('Fit did not converge')
    yerr = np.sqrt(langau(x,
                          mpv=m.values['mpv'],
                          eta=m.values['eta'],
                          sigma = m.values['sigma'],
                          A = m.values['A']))
    yerr = np.sqrt(y)
    yerr[y <1 ] = 1
    m = iminuit.Minuit(minimizeMe, 
                       mpv = m.values['mpv'], limit_mpv = limit_mpv, error_mpv = 1, 
                       eta = m.valuesp0[1], error_eta = .1, limit_eta = limit_eta, 
                       sigma= p0[2], error_sigma = .1, limit_sigma = limit_sigma, 
                       A = p0[3], error_A= 1, limit_A = limit_A, errordef = 1, print_level = 2)
    m.migrad()
    fit_values = m.values
    values = np.array([fit_values['mpv'], fit_values['eta'], fit_values['sigma'], fit_values['A']])
    m.hesse()
    m.minos()
    minos_errors = m.get_merrors()
    

x = trace.xvalues 
#y = langau(x, mpv = 30., eta = 5,. sigma = 4, A = 1000.)
y = inverted_yvalues
values, errors, m = fit_landau_migrad(x, y, p0 = [x.shape[0]/2,.10,.10,.np.max(y)], 
                                      limit_mpv = (10., 100.), limit_eta = (2, 20.), limit_sigma=(2., 20.), limit_A = (500., 1500.))
yerr = np.sqrt(langau(x, *values))
plt.errorbar(x, y, yerr, fmt = '.')
plt.plot(x, langau(x, *values), '-', label = 'Fit:')
plt.show()
    
                      

#x = trace.xvalues
#for A, eta, mpv in ((1, 1, 10), (1,2,30), (.5, 5, 50)):
#    plt.figure(1)
 #   y = np.array([pylandau.get_landau(x, mpv, eta, A) for x_value in x ])
 #   plt.plot(trace.xvalues, y)
#    plt.plot(trace.xvalues, pylandau.landau(trace.xvalues, mpv, eta, A), '-', label = 'mu%1.1f, eta = %1.1f, A = %1.1f' % (mpv, eta, A))
   
