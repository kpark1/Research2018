#!/usr/bin/env python
import sys
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mlp
import ScopeTrace
from scipy.optimize import curve_fit
import scipy.integrate
import scipy.optimize


#---------------------------------------------------------------------------------------------------
# M A I N
#---------------------------------------------------------------------------------------------------
# initial settings
mlp.rcParams['axes.linewidth'] = 2

for filename in sys.argv[1:]:
    print ' File to open: ' + filename
    with open(filename,"r") as file:
        data = file.read()

# decode the scope trace
trace = ScopeTrace.ScopeTrace(data,1)

# find baseline and jitter
baseline,jitter = trace.find_baseline_and_jitter(0,250)
#print ' Baseline: %10.6f,  Jitter: %10.6f'%(baseline,jitter)

inverted_yvalues = []
for value in trace.yvalues:
    inverted_yvalue = -(value-baseline)
    inverted_yvalues.append(inverted_yvalue)
x= trace.xvalues
y = inverted_yvalues
i = 0
#k = len(y)
k = len(trace.xvalues)/4
x_1= trace.xvalues[i:k]
y_1 = inverted_yvalues[i:k]

n= len(x)
#sigmas = range(.00001, .01, 5)
sigma = .002
mean = sum(y)/n
#gaussian function
def integrand(t, args):
    mu,c = args
    return np.exp(-t)*np.cos(t*(x? - mu)/ c + 2*t*log10(t/c)/np.pi)/np.pi

def landau_2():
    ? = scipy.integrate.quad(integrand, 

def landau(x_1, a):
    return a*np.exp(-(x_1+ np.exp(-x_1))/2)

#popt
#for sigma in sigmas:
popt, pcov = curve_fit(landau, x_1, y_1, p0 = .2 )

print(popt)

y2= landau(x_1,.00016474)
plt. plot(x,y, 'r', label = 'data')
plt.plot(x_1, y2, 'b', label = 'fit')
plt. legend()
plt.show()
