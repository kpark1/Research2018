#!/usr/bin/env python
import sys, os, ScopeTrace, pylandau
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.signal import argrelextrema
from itertools import product
from random import choice
import numpy.polynomial.polynomial as poly

#-------------------------------------------------------------------------------
class ScopeTrace():
    def __init__(self, data, n_average = 1):
        self.data = data
        self.n_average = n_average
        self.xvalues = []
        self.yvalues = []
        x=0
        y=0
        n=0
        i = 0
        for line in data.split('\n'):
            f = line.split(',')
            if len(f) <5:
                continue
            x+= float(i)
            y+= float(f[4])
            n+=1
            if n>n_average:
                self.xvalues.append(x/n)
                self.yvalues.append(y/n)
                n= 0
                x= 0
                y= 0
            i +=1

    def find_baseline_and_jitter(self, xmin, trigger_offset):
        n = 0
        sum = 0
        sum2 = 0
        for x,y in zip(self.xvalues,self.yvalues):
            sum = sum + y
            sum2 = sum2 + y*y
            n = n + 1
        baseline = sum/n
        jitter = sum2/n - baseline*baseline
        return (baseline,jitter)

    def inverted(self, xmin, trigger_offset= 250):
        baseline,jitter = self.find_baseline_and_jitter(xmin,trigger_offset)
        inverted_y = [-(val-baseline) for val in self.yvalues]
        return inverted_y
    def parameters(self):
        x= self.xvalues
        y= self.inverted(0, 250)
        y_array = np.array(y)
        idx = np.where(y_array==y_array.max())
        idx = idx[0][0]
        x_values_peak = x[idx]
        
        mpv = x_values_peak
        rmin=1
        
        landau_par_rmin, pcov_rmin = curve_fit(pylandau.landau, x, y, p0= (mpv, rmin, rmin))
        array_1 = np.ndarray.tolist(np.around(landau_par_rmin, decimals = 3))
        param_list = [array_1]
        workinglandaupar = [array_1]
        def diff_sq_fn(parameter):
            return round(sum((y-pylandau.landau(x, *parameter))**2), 4)
        initial_diff_sq = [diff_sq_fn(landau_par_rmin)]
        
        for eta, A in product(np.linspace(rmin, 25,5 ), np.linspace(rmin, 25, 5)):
            try:
                landau_par, pcov = curve_fit(pylandau.landau, x, y, p0= (mpv, eta,A))
                landau_par = np.ndarray.tolist(np.around(landau_par, decimals =3))
                diff= diff_sq_fn(landau_par)
                par = param_list[0]
                if initial_diff_sq[0] < .01:
                    break
                elif landau_par != par and diff < initial_diff_sq[0]:
                    param_list.append(landau_par)
                    workinglandaupar[0] = landau_par
                    initial_diff_sq[0] = diff
                    break
                else:
                    continue
            except RuntimeError as message:
                print(str(message))
                continue
            except TypeError as message:
                print(str(message))
            except ValueError as message:
                print(str(message))
        return  workinglandaupar
    
    
#class Scopedata(Scopetrace):
    #def __init__(self, data, n_average):
        #super.(Scopetrace, self).__init__(data, n_average = 1)
      
    #def read(self):
        #for file in sorted(os.list

   
    #def storeparameters



