#!/usr/bin/env python
import sys
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mlp
import ScopeTrace
from scipy.optimize import curve_fit
import pylandau

#---------------------------------------------------------------------------------------------------
# M A I N
#---------------------------------------------------------------------------------------------------
# initial settings
mlp.rcParams['axes.linewidth'] = 2

for filename in sys.argv[1:]:
    print ' File to open: ' + filename
    with open(filename,"r") as file:
        data = file.read()
# decode the scope trace
trace = ScopeTrace.ScopeTrace(data,1)

# find baseline and jitter
baseline,jitter = trace.find_baseline_and_jitter(0,250)
#print ' Baseline: %10.6f,  Jitter: %10.6f'%(baseline,jitter)

inverted_yvalues = []
for value in trace.yvalues:
    inverted_yvalue = -(value-baseline)
    inverted_yvalues.append(inverted_yvalue)
#x= np.arange(0,100,0.1)
x = trace.xvalues[0:800] 
x = np.array(x)
y = inverted_yvalues[0:800] 


#initial guess
#mpv, eta,  A = 3, 5, 1
#mpv = the peak
#
#mpv= 280
#A = 1
#for  eta
mpv, eta, A = 360 ,30, .23
def meow(x, mpv, eta, A):
    return pylandau.landau(x, mpv, eta, A)[0]
    
coeff, pcov = curve_fit(meow, x, y, p0= (mpv, eta, A), bounds = (0, 900), max_nfev = 10000000)
print(coeff)
y3 = pylandau.landau(x, *coeff)
plt.plot(x, y3,'g',label = 'fit')
plt.plot(x, y, 'b')


mean = sum(inverted_yvalues)/len(trace.xvalues)
sigma = .002
def gaus(x, a, x0, sigma):
    #print(x)
    return a*np.exp(-(x-x0)**2/(2*sigma**2))
popt, pcov = curve_fit(gaus, x,y, p0=[1,mean,sigma] )
y2 = gaus(x, *popt)
plt.plot(x, y2, 'r')
plt.show()
