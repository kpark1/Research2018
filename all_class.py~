#!/usr/bin/env python
import sys, os, pylandau
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from itertools import product
from random import choice


#-------------------------------------------------------------------------------
class ScopeTrace():
    def __init__(self, data, n_average = 1, xmin=0):
        self.data = data
        self.n_average = n_average
        self.xvalues = []
        self.yvalues = []
        self.xmin = xmin
        try: 
            self.sample_interval = self.find_value('Sample Interval', data)
        except: 
            self.sample_interval = 1

        try: 
            self.trigger_point = self.find_value('Trigger Point', data)* self.sample_interval + self.xvalues[0]
        except:
            try: 
                self.trigger_point= self.find_value('Trigger Offset', data)
            except:
                self.trigger_point = 250
        x=0
        y=0
        n=0
        i = 0
        for line in data.split('\n'):
            f = line.split(',')
            if len(f) <5:
                continue
            x+= float(i)
            y+= float(f[4])
            n+=1
            if n>=n_average:
                self.xvalues.append(x/n)
                self.yvalues.append(y/n)
                n= 0
                x= 0
                y= 0
            i +=1

    def trigger_point(self):
        return self.trigger_point   
 
    def find_baseline_and_jitter(self):
        #to call
        #baseline, jitter = trace.find_baseline_and_jitter
        n = 0
        sum = 0
        sum2 = 0
        
        for x,y in zip(self.xvalues,self.yvalues):

            if x> self.xmin and x< self.trigger_point:
                sum = sum + y
                sum2 = sum2 + y*y
                n = n + 1
        baseline = sum/n
        jitter = sum2/n - baseline*baseline
        return (baseline,jitter)

    def inverted(self):
        baseline,jitter = self.find_baseline_and_jitter()
        return [-(val-baseline) for val in self.yvalues]

    def diff_sq_fn(self, parameter):
        y= np.asarray(self.inverted())
        self.xvalues = np.asarray(self.xvalues)
        return round(sum((y-pylandau.landau(self.xvalues, *parameter))**2), 4)

    def parameters(self):
        #to call
        # trace = all_class.cp.ScopeTrace(data) ...print(trace.parameters())
        #use index number instead of self.xvalues as rescaling enables the pylandau.landau function to find parameters
        x= np.linspace(0, len(self.xvalues)-1, len(self.xvalues))
        y= self.inverted()
        
        #find the x value of the largest peak
        y_array = np.array(y)
        idx = np.where(y_array==y_array.max())
        idx = idx[0][0]
        x_values_peak = x[idx]
        
        #make initial guess for parameters mpv, eta, A, which correspond to the x value, width, and amplitude of the peak
        mpv = x_values_peak
        rmin=1
        landau_par_rmin, pcov_rmin = curve_fit(pylandau.landau, x, y, p0= (mpv, rmin, rmin))
        array_1 = np.ndarray.tolist(np.around(landau_par_rmin, decimals = 3))
        param_list = [array_1]
        workinglandaupar = [array_1]
        initial_diff_sq = [self.diff_sq_fn(landau_par_rmin)]
        
        #checks if initial guess is a good fit and if not, loop through a range of possible parameters to make new guesses until a set of parameters has a decent fit
        for eta, A in product(np.linspace(rmin,25,5), np.linspace(rmin,25,5)):
            try:
                landau_par, pcov = curve_fit(pylandau.landau, x, y, p0= (mpv, eta,A))
                landau_par = np.ndarray.tolist(np.around(landau_par, decimals =3))
                diff= self.diff_sq_fn(landau_par)
                par = param_list[0]
                if initial_diff_sq[0] < .01:
                    break
                elif landau_par != par and diff < initial_diff_sq[0]:
                    param_list.append(landau_par)
                    workinglandaupar[0] = landau_par
                    initial_diff_sq[0] = diff
                    break
                else:
                    continue
            except RuntimeError as message:
                print(str(message))
                continue
            except TypeError as message:
                print(str(message))
            except ValueError as message:
                print(str(message))
        mpv = workinglandaupar[0][0]*self.sample_interval
        eta = workinglandaupar[0][1]*self.sample_interval
        A = workinglandaupar[0][2]*self.sample_interval
        return (mpv, eta, A) 
    
    
    def plot(self, parameters= None):
        #parameters in an array   
        x= np.array(self.xvalues)
        y = np.array(self.inverted())
        plt.plot(x,y, label = 'Data')
        if (parameters != None) and (len(parameters) ==3):
            plt.plot(x, pylandau.landau(np.linspace(0, len(x)-1, len(x)), parameters[0]/self.sample_interval, parameters[1]/self.sample_interval, parameters[2]/self.sample_interval), label = 'Landau Fit')
            plt.show()
